# 故事生成任务接口流程文档

## 概述

本文档详细描述了用户点击"生成"按钮后，从前端到服务端的完整接口调用流程。

## 前端流程

### 1. 用户操作

- 用户在 `StoryLibraryPage.vue` 中点击"生成"按钮
- 触发 `showConfirmDialog(story.id)` 显示确认对话框
- 用户确认后调用 `confirmGenerate()` 函数

### 2. 前端 API 调用

**文件**: `story-web/src/api/audioTask.js`

```javascript
// 创建生成任务
POST /api/generate_by_ids
请求体:
{
  story_id: number,      // 故事ID
  user_id: number,       // 用户ID
  role_id: number,       // 角色ID
  task_name: string      // 任务名称（可选）
}

响应:
{
  task_id: string,       // 任务ID（UUID格式）
  status: "pending",     // 任务状态
  message: string,       // 提示信息
  created_at: string     // 创建时间
}
```

### 3. 前端轮询机制

- 任务创建成功后，前端开始轮询任务状态
- 每 5 秒调用一次 `GET /api/task/{task_id}`
- 轮询持续到任务完成或失败

```javascript
// 获取任务状态
GET /api/task/{task_id}

响应:
{
  task_id: string,
  status: "pending" | "processing" | "completed" | "failed",
  progress: string,       // 进度描述
  current_step: number,  // 当前步骤（1-4）
  total_steps: number,  // 总步骤数（4）
  steps: [...],         // 各步骤执行结果
  output_wav: string,   // 输出音频文件路径（完成时）
  error: string,        // 错误信息（失败时）
  created_at: string,
  updated_at: string,
  completed_at: string
}
```

---

## 服务端流程

### 接口入口

**文件**: `tts-story/app/main.py` 或 `tts-story/scripts/audio_generation_api.py`

**接口**: `POST /api/generate_by_ids`

### 处理流程

#### 步骤 1: 接收请求并验证

```python
@app.post("/api/generate_by_ids", response_model=TaskResponse)
async def create_generate_task_by_ids(request: GenerateByIdsRequest):
    # 接收参数: story_id, user_id, role_id, task_name
```

#### 步骤 2: 准备生成参数

**文件**: `tts-story/app/services/business_generate.py`

调用 `business_generate_service.prepare_generation_params()`:

1. **读取故事配置文件**

   - 文件路径: `config/story_library_{story_id}.json`
   - 必需字段:
     - `json_db`: 数据库 JSON 文件路径
     - `emo_audio_folder`: 情绪音频文件夹路径
     - `bgm_path`: 背景音乐文件路径
     - `script_json`: 脚本 JSON 文件路径
     - `source_audio`: 源音频文件路径（可选）
     - `dialogue_audio_folder`: 对话音频文件夹路径（已切割好的对白音频文件夹，可选）

2. **查询用户音频路径**

   - 通过 `UserInputAudioDAO` 查询数据库
   - 表: `user_input_audio`
   - 条件: `user_id` 和 `role_id`
   - 获取字段: `clean_input`（用户克隆声音文件路径）

3. **组装生成参数**
   ```python
   params = {
       "input_wav": input_wav,              # 用户克隆声音
       "json_db": config["json_db"],        # 数据库JSON
       "emo_audio_folder": config["emo_audio_folder"],  # 情绪音频文件夹
       "source_audio": config.get("source_audio", ""),  # 源音频
       "script_json": config["script_json"], # 脚本JSON
       "bgm_path": config["bgm_path"],       # 背景音乐
       "dialogue_audio_folder": config.get("dialogue_audio_folder", ""),  # 对话音频文件夹
       "task_name": task_name               # 任务名称
   }
   ```

#### 步骤 3: 创建任务记录

**文件**: `tts-story/app/services/task_manager.py`

```python
# 生成唯一任务ID（UUID）
task_id = str(uuid.uuid4())

# 创建任务记录
task = task_manager.create_task(
    task_id=task_id,
    task_name=params.get("task_name"),
    total_steps=4
)

# 任务状态保存到:
# - 内存字典: task_manager.tasks
# - 持久化文件: data/tasks.json
```

#### 步骤 4: 提交后台任务

```python
# 提交到线程池后台执行
executor.submit(generate_audio_pipeline, task_id, params)

# 立即返回任务ID给前端
return TaskResponse(
    task_id=task_id,
    status=TaskStatus.PENDING,
    message="任务已创建，正在后台执行",
    created_at=task["created_at"]
)
```

---

## 音频生成流水线

**文件**: `tts-story/app/services/audio_pipeline.py`

### 流水线概述

音频生成分为 4 个主要步骤（实际需要 5 个步骤），在后台线程中顺序执行：

```
Step 1: Voice Cloning (语音克隆) - 生成旁白音频
   ↓
Step 2: Trim Silence (去除静音) - 处理旁白音频
   ↓
Step 3: Build Sequence (构建序列) - 生成时间轴配置
   ↓
Step 4: Alignment (对齐合成) - 合成最终音频（旁白+对白+BGM）
```

**重要说明**:

- Step 4 需要同时提供旁白和对白两个音频文件夹
- 旁白音频文件夹：Step 2 的输出（`2_trimmed/`）
- 对白音频文件夹：配置文件中的 `dialogue_audio_folder` 字段（已切割好的对白音频文件夹）

### 工作目录结构

每个任务创建独立的工作目录：

```
data/tasks/{task_id}/
├── 1_cloned/          # Step 1 输出：克隆的旁白音频文件
├── 2_trimmed/         # Step 2 输出：去除静音后的旁白音频
├── 3_sequence.json    # Step 3 输出：音频序列配置（包含时间轴信息）
└── 4_final_output.wav # Step 4 输出：最终合成音频（旁白+对白+BGM）

注意：对白音频文件夹来自配置文件中的 dialogue_audio_folder 字段，不在任务工作目录中
```

### GPU 并发控制

- 使用 `threading.Semaphore(1)` 限制同时只有 1 个任务执行 AI 推理
- 防止 GPU 显存溢出
- Step 1（语音克隆）需要 GPU，其他步骤为 CPU 处理

---

### Step 1: Voice Cloning (语音克隆)

**文件**: `tts-story/scripts/auto_voice_cloner.py`

**功能**: 根据用户输入音频和情绪音频，生成克隆语音片段

**输入**:

- `input_wav`: 用户克隆声音文件
- `json_db`: 数据库 JSON 文件（包含文本和情绪信息）
- `emo_audio_folder`: 情绪音频文件夹

**输出**:

- `data/tasks/{task_id}/1_cloned/`: 克隆的音频文件列表

**执行脚本**: `run_voice_cloning()`

**状态更新**:

```python
task_manager.update_task(
    task_id=task_id,
    status=TaskStatus.PROCESSING,
    progress="Step 1/4: 正在执行语音克隆...",
    current_step=1
)
```

---

### Step 2: Trim Silence (去除静音)

**文件**: `tts-story/scripts/trim_silence_tool.py`

**功能**: 去除音频文件开头和结尾的静音部分

**输入**:

- `input_dir`: Step 1 的输出目录（`1_cloned/`）
- `silence_thresh`: 静音阈值（默认 -40dB）

**输出**:

- `data/tasks/{task_id}/2_trimmed/`: 去除静音后的音频文件

**执行脚本**: `run_trim_silence()`

**状态更新**:

```python
task_manager.update_task(
    task_id=task_id,
    progress="Step 2/4: 正在去除静音...",
    current_step=2
)
```

---

### Step 3: Build Sequence (构建序列)

**文件**: `tts-story/scripts/build_story_sequence.py`

**功能**: 根据脚本 JSON 和音频文件，构建音频序列配置

**输入**:

- `source_audio`: 源音频文件路径
- `script_json`: 脚本 JSON 文件（包含文本序列和情绪信息）
- `audio_folders`: 音频文件夹列表（优先使用 `2_trimmed/`）

**输出**:

- `data/tasks/{task_id}/3_sequence.json`: 音频序列配置文件

**执行脚本**: `run_build_sequence()`

**状态更新**:

```python
task_manager.update_task(
    task_id=task_id,
    progress="Step 3/4: 正在构建音频序列...",
    current_step=3
)
```

---

### Step 4: Alignment (对齐合成)

**文件**: `tts-story/scripts/align.py`

**功能**: 根据序列配置对齐音频片段，添加背景音乐，合成最终音频

**输入**:

- `config_json`: Step 3 生成的序列配置文件
- `audio_folders`: **音频文件夹列表（需要包含两个文件夹）**
  1. **旁白音频文件夹**: `data/tasks/{task_id}/2_trimmed/` (Step 2 的输出)
  2. **对白音频文件夹**: 配置文件中的 `dialogue_audio_folder` 字段（已切割好的对白音频文件夹）
- `bgm_path`: 背景音乐文件路径

**输出**:

- `data/tasks/{task_id}/4_final_output.wav`: 最终合成音频文件

**执行脚本**: `run_alignment()`

**音频搜索逻辑**:

- `align.py` 会在 `audio_folders` 列表中的所有文件夹中搜索音频文件
- 搜索顺序：先搜索旁白文件夹，再搜索对白文件夹
- 文件匹配规则：
  - 优先匹配 `filename` 字段指定的文件名
  - 其次匹配 `{id}-{text}.wav` 或 `{id}.wav` 模式
  - 支持模糊匹配（文件名以 `{id}-` 或 `{id}_` 开头）

**当前问题**:

- ⚠️ **缺少对白音频文件夹**: 当前 `audio_folders` 只包含旁白音频文件夹
- ⚠️ **缺少源音频切割步骤**: 没有从 `source_audio` 中切割对白音频的步骤
- **影响**: 生成的最终音频只有旁白，缺少对白部分

**状态更新**:

```python
task_manager.update_task(
    task_id=task_id,
    progress="Step 4/4: 正在对齐合成最终音频...",
    current_step=4
)
```

**正确的调用方式**:

```python
# 构建音频文件夹列表：包含旁白和对白两个文件夹
audio_folders = [str(trimmed_dir)]  # 旁白音频文件夹

# 如果配置中提供了对话音频文件夹，添加到列表中
dialogue_audio_folder = params.get("dialogue_audio_folder", "")
if dialogue_audio_folder and os.path.exists(dialogue_audio_folder):
    audio_folders.append(dialogue_audio_folder)  # 对白音频文件夹

result_step4 = run_alignment(
    config_json=str(sequence_json),
    audio_folders=audio_folders,  # 包含旁白和对白两个文件夹
    bgm_path=params["bgm_path"],
    output_wav=str(final_output),
)
```

---

## 任务完成

### 成功完成

```python
task_manager.update_task(
    task_id=task_id,
    status=TaskStatus.COMPLETED,
    progress="✅ 任务完成！所有步骤已成功执行",
    current_step=4,
    result=final_result,
    output_wav=str(final_output)
)
```

**最终结果**:

```python
{
    "task_dir": "data/tasks/{task_id}",
    "output_wav": "data/tasks/{task_id}/4_final_output.wav",
    "step1_voice_cloning": {...},
    "step2_trim_silence": {...},
    "step3_build_sequence": {...},
    "step4_alignment": {...}
}
```

### 任务失败

```python
task_manager.update_task(
    task_id=task_id,
    status=TaskStatus.FAILED,
    progress="❌ 任务失败",
    error=error_message
)

# 自动删除失败的任务
task_manager.delete_task(task_id)
```

---

## 任务状态查询接口

**接口**: `GET /api/task/{task_id}`

**文件**: `tts-story/app/main.py`

**实现**:

```python
@app.get("/api/task/{task_id}", response_model=TaskStatusResponse)
async def get_task_status(task_id: str):
    task = task_manager.get_task(task_id)

    if task is None:
        raise HTTPException(status_code=404, detail=f"任务不存在: {task_id}")

    return TaskStatusResponse(**task)
```

**响应字段**:

- `task_id`: 任务 ID
- `status`: 任务状态（pending/processing/completed/failed）
- `progress`: 进度描述文本
- `current_step`: 当前步骤（0-4）
- `total_steps`: 总步骤数（4）
- `steps`: 各步骤执行结果数组
- `output_wav`: 输出音频文件路径（完成时）
- `error`: 错误信息（失败时）
- `created_at`: 创建时间
- `updated_at`: 更新时间
- `completed_at`: 完成时间

---

## 数据持久化

### 任务状态存储

**文件**: `tts-story/app/services/task_manager.py`

- **内存存储**: `task_manager.tasks` 字典
- **持久化文件**: `data/tasks.json`
- **更新机制**: 每次状态变更自动保存到文件
- **线程安全**: 使用 `threading.Lock()` 保证线程安全

### 任务工作目录

- **路径**: `data/tasks/{task_id}/`
- **内容**: 包含 4 个步骤的中间文件和最终输出
- **保留策略**: 任务完成后保留，失败任务自动删除

---

## 错误处理

### 参数验证错误

- **配置文件不存在**: 返回 404
- **数据库查询失败**: 返回 400
- **缺少必需参数**: 返回 400

### 任务执行错误

- **Step 失败**: 记录错误信息，更新任务状态为 `failed`
- **自动清理**: 失败任务自动从任务管理器删除
- **错误日志**: 详细错误信息记录到 `app.log`

---

## 相关文件清单

### 前端文件

- `story-web/src/pages/StoryLibraryPage.vue` - 故事库页面
- `story-web/src/api/audioTask.js` - 音频任务 API

### 服务端核心文件

- `tts-story/app/main.py` - FastAPI 主应用，接口入口
- `tts-story/scripts/audio_generation_api.py` - 音频生成 API 路由
- `tts-story/app/services/business_generate.py` - 业务层生成服务
- `tts-story/app/services/audio_pipeline.py` - 音频生成流水线
- `tts-story/app/services/task_manager.py` - 任务管理器

### 流水线脚本文件

- `tts-story/scripts/auto_voice_cloner.py` - Step 1: 语音克隆
- `tts-story/scripts/trim_silence_tool.py` - Step 2: 去除静音
- `tts-story/scripts/build_story_sequence.py` - Step 3: 构建序列
- `tts-story/scripts/align.py` - Step 4: 对齐合成

### 数据访问层

- `tts-story/scripts/user_input_audio_dao.py` - 用户音频数据访问
- `tts-story/scripts/task_dao.py` - 任务数据访问（数据库）

### 配置文件

- `tts-story/config/story_library_{story_id}.json` - 故事配置文件

### 数据文件

- `tts-story/data/tasks.json` - 任务状态持久化文件
- `tts-story/data/tasks/{task_id}/` - 任务工作目录

---

## 流程图

```
用户点击"生成"
    ↓
前端: confirmGenerate()
    ↓
POST /api/generate_by_ids
    ↓
服务端: create_generate_task_by_ids()
    ├─→ 准备生成参数
    │   ├─→ 读取配置文件 (story_library_{id}.json)
    │   └─→ 查询用户音频 (user_input_audio表)
    ├─→ 创建任务记录 (task_manager)
    └─→ 提交后台任务 (executor.submit)
    ↓
立即返回 task_id
    ↓
前端开始轮询: GET /api/task/{task_id}
    ↓
后台执行: generate_audio_pipeline()
    ├─→ Step 1: Voice Cloning (GPU) - 生成旁白音频
    ├─→ Step 2: Trim Silence (CPU) - 处理旁白音频
    ├─→ Step 3: Build Sequence (CPU) - 生成时间轴配置
    └─→ Step 4: Alignment (CPU) - 合成最终音频（旁白+对白+BGM）
      - 旁白音频：使用 Step 2 的输出
      - 对白音频：使用配置文件中的 dialogue_audio_folder
    ↓
任务完成/失败
    ↓
前端轮询检测到状态变化
    ├─→ completed: 显示成功，刷新故事书列表
    └─→ failed: 显示错误信息
```

---

## 注意事项

1. **GPU 资源限制**: 同时只有 1 个任务在执行 GPU 推理（Step 1）
2. **任务超时**: 前端 localStorage 中任务数据 30 分钟超时
3. **任务持久化**: 任务状态保存在 `data/tasks.json`，服务重启后可恢复
4. **工作目录**: 每个任务有独立的工作目录，包含所有中间文件
5. **错误处理**: 失败任务会自动删除，但工作目录可能保留
6. **轮询频率**: 前端每 5 秒轮询一次任务状态

## 配置说明

### 对话音频文件夹配置

在 `config/story_library_{story_id}.json` 配置文件中，可以添加 `dialogue_audio_folder` 字段来指定已切割好的对白音频文件夹路径。

**配置字段**:

- `dialogue_audio_folder`: 对话音频文件夹路径（可选）
  - 此文件夹应包含已切割好的对白音频文件
  - 文件命名格式应为：`{id}-{text}.wav` 或 `{id}.wav`（与 `align.py` 搜索模式匹配）
  - 如果未提供此字段，Step 4 将只使用旁白音频（会显示警告日志）

**配置示例**:

```json
{
  "json_db": "/path/to/json_db.json",
  "emo_audio_folder": "/path/to/emo_audio",
  "source_audio": "/path/to/source_audio.mp3",
  "script_json": "/path/to/script.json",
  "bgm_path": "/path/to/bgm.mp3",
  "dialogue_audio_folder": "/path/to/dialogue_audio",
  "task_name": "story_task"
}
```

**文件命名要求**:

对白音频文件夹中的文件命名需要匹配 `align.py` 的搜索模式：

- `{id}-{text}.wav` 或 `{id}-{text}.mp3`
- `{id}_{text}.wav` 或 `{id}_{text}.mp3`
- `{id}.wav` 或 `{id}.mp3`
- 或者文件名以 `{id}-` 或 `{id}_` 开头

其中 `{id}` 对应序列配置中的 `id` 字段，`{text}` 对应文本内容（会被清理用于文件名）。
